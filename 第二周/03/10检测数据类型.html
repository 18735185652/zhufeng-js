<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<div id="div1"></div>
<script>
    //1. typeof 用来检测数据类型的运算符
//    console.log(typeof 12);
//    var num = "zhufeng";
//    console.log(typeof num);
    //->使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串中包含了对应的数据类型
    //例如："number"、"string"、"boolean"、"undefined","function","object"

//    console.log(typeof typeof typeof function(){}) //"string"
    //局限性：
    // typeof null的是字符串"object"
    //不能具体的戏份是数组还是正则，还是其他的值，因为使用typeof检测数据类型对于对象数据类型中的
    //值，返回的结果都是"object"

//    function fn(num1,num2){
//        if(typeof num2==="undefined"){
//            num2=0;
//        }
//        num2 = num2||0  //定义不严谨
//    }
//    fn(0,false)

//    function fn(callback){
//        typeof callback==="function"?callback():null;
//          callback&&callback(); // 不严谨
//    }
//    fn(function(){

//    });


    //2. instanceof 检测某一个实例是否属于这个类
//    var obj = [12,23];
//    console.log(obj instanceof Array); //true
//    console.log(obj instanceof RegExp);//false

//->局限性(哇咔咔 好多呀)
    //1.不能用来检测和处理字面量方式创建出来的基本数据类型的值
    //->对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的
    //从严格意义来讲只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这个类的一个实例；
    //对于字面量方式创建出来的结果是基本数据类型的值，不是严谨的实例，但是由于JS的松散特点，导致可以使用Number.prototype
    //上提供的方法
    //console.log(1 instanceof Number); //false
    /console.log("" instanceof String); //false
    //console.log(new Number(1) instanceof Number); //true
    //2.
//    var ary = [];
//    console.log(ary instanceof Array);//true;
//    console.log(ary instanceof Object);//true;
//
//    function fn(){};
//    console.log(fn instanceof Function);//true;
//    console.log(fn instanceof Object);//true;

    //在类的原型继承中，我们最后检测出来的结果未必准确
//    function Fn(){
//
//    }
//    Fn.prototype = new Array;
//    var f= new Fn;
//    console.log(f instanceof Array)//true f是函数，不是数据 但结果是true


    //3. constructor 构造函数  作用和instanceof非常的相似
        var obj = [];
        console.log(obj.constructor===Array); // true
        console.log(obj.constructor===RegExp);
    //constructor 可以处理基本数据类型
        var num = 1;
        console.log(num.constructor===Number) //true 可以处理基本数据类型
    var reg = /^$/;
        //constructor检测Object和instanceof不一样，一般情况下是检测不了的
        console.log(reg.constructor===RegExp) //true
        console.log(reg.constructor===Object) //false
        //局限性：我们可以把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了
        //这样检测出来的结果就不准确了
         function Fn(){
         }
         Fn.prototype = new Array;
         var f= new Fn;
         console.log(f.constructor)//Array
    //对于特殊的数据类型 null和undefined他们的所属类是null和undefined；但是浏览器把这两个类保护起来了
    //不允许我们在外边访问使用


    //4. Object.proto.toString().call() //最准确最常用的方式
    //首先获取Object原型上的toString方法，让方法执行，并且改变方法中的this关键字


    //5.toString的理解
    //->乍一看应该是转换为字符串，但是某些toString方法不仅仅是转换为字符串
    console.log((1).toString()); //"1" Number.prototype.toString 转换为字符串








</script>


</body>
</html>