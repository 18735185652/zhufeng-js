<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
//    function Fn(){
//        this.x = 100;
//        this.getX=function(){
//            //this ->需要看getX执行的时候才知道
//            console.log(this.x)
//        }
//    }
//    var f1=new Fn;
//    f1.getX() //->方法中的this是f1
//    var ss=f1.getX;
//    ss() // this指的是window ->undefined
    //1.在构造含函数模式中new Fn执行，如果Fn()不需要传递参数的额话，后面的小括号可以省略
    //2.this的问题：在类中出现的this.xxx=xxx中的this都是当前类的实例，而某一个属性值(方法)
    //方法中的this需要看方法执行的时候,前面是否有".",才能知道this是谁



    function Fn(){
        var num = 10;
        this.x = 100;
        this.getX=function(){
            //this ->需要看getX执行的时候才知道
            console.log(this.x)
        }
        return {name:"珠峰"};
    }
    var f1=new Fn;
    console.log(f1); //->{name: "珠峰"}
    //3.类有普通函数的一面，当函数执行的时候，var num 其实只是当前形成的私有作用域中的私有变量而已，
    // 他和我们f1这个实例没有任何的关系，只有this.xxx=xxx 才相当于给f1这个实例增加私有的属性和方法
    // 才和我们的f1有关系...

//    4.在构造函数模式中，浏览器会默认的把我们的实例返回(返回的是一个对象数据类型的值)；如果我们自己手动写了return
//    返回
//
//    返回的是一个基本数据类型的值，当前的实例是不变的，例如return 100；f1还是当前Fn类的实例
//    返回的是一个引用数据类型的值，当前 的实例会被自己返回的值给替换掉，例如 return {name:"珠峰"};我们的
//    f1就不在是Fn的实例了，而是对象




function Fn(){
    this.x = 100;
    this.getX=function(){
        //this ->需要看getX执行的时候才知道
        console.log(this.x)
    }
}
    var f1=new Fn;
    console.log(f1); //->
//
////5 检测某一个实例是否属于这个类->instanceof
//    console.log(f1 instanceof Fn); //true
//    console.log(f1 instanceof Array); //false
//    console.log(f1 instanceof Object); //true  因为所有的实例都是对象数据类型的，而每一额对象数据类型都是Object这个内置类的一个实例，
//    //所以f1也是它的一个实例
//    //对于检测数据类型来说 type of有自己的额局限性，不能细分Object下的对象，数组，正则...
//    var a=[];
//    console.log(a instanceof Array); //true 说明a是一个数组


function Fn(){
    this.x = 100;
    this.getX=function(){
        //this ->需要看getX执行的时候才知道
        console.log(this.x)
    }
}
    var f1=new Fn;
    var f2=new Fn;
    //6. f1和f2都是Fn在这个类的一个实例，都拥有x和getX两个属性，但是这两个属性是各自的私有的属性，所以：
//    console.log(f1.getX===f2.getX)//false

//in:检测某一个属性是否属于这个对象 (attr in object)不管是私有的属性还是公有的属性，只要存在，用in来检测都是true
//cosole.log("getx" in f1); //true
//hasOwnProperty:用来检测某一个属性是否为这个对象的"私有属性"，这个方法只能检测私有的属性
console.log(f1.hasOwnProperty("getX"))//->true "getX"是f1的私有属性

//思考：检测某一个属性是否为该对象的“公有属性” hasPubProperty
//    function hasPubProperty(obj,attr){
//        //首先保证是它的一个属性并且还不是私有的属性，那么只能是公有的属性了
//        return (attr in obj) && !obj.hasOwnProperty(attr);
//    }
//    console.log(hasPubProperty(f1,"getX")) //false
// 7. isPrototypeOf 自己回去查看高程三


























</script>

</body>
</html>