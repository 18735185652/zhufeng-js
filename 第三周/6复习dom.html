<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="div1">
        <span></span>
        <span></span>
        <span></span>
        <p>
            <span></span>
            <span></span>
            <span></span>
        </p>
    </div>
<script>
//->获取页面中元素的方法
//document.getElementById();
//context.getElementsByTagName(tagname) // 把指定容器中子子孙孙辈分的所有标签名为tagname的都获取到了
//context.getElementsByClassName(classname) ->IE6-8不兼容
//document.getElementsByName() //->在IE浏览器中只对表单元素起作用
//document.body
//document.documentElement
//context.querySelector/context.querySelectorAll  获取到的集合不存在映射关系

//描述节点和节点之间关系的属性(在标准浏览器中会把空格和换行当做文本节点处理)
//childNodes 获取所有的子节点
//children  获取所有的元素子节点 ->在IE6-8下获取的结果和标准浏览器获取的结果不一致
//parentNode 父节点
//previousSibling/previousElementSibling //获取上一个哥哥节点/获取上一个哥哥元素节点 
//nextSibling/nextElementSibling
//lastChild/lastElementChild //第一个节点/第一个元素节点
//firstChild/firstElementChild

//动态操作Dom方法 增删改
createElement
document.createDocumentFragment() //创建文档碎片
//appendChild
//insertBefore
//cloneNode(true/false)
// replaceChild
// removeChild
// get/set/removeAttribute 


//Dom盒子模型


 var oDiv = document.getElementById("div1");
 console.log(oDiv.getElementsByTagName("span"));

//接下来写的所有方法在jQuery中的作用和方法名一模一样
// function children ->获取某一个容器中所有的元素节点(还可以筛选出指定标签名的)

//getElementByClass ->通过元素的样式类名获取一组元素 兼容所有浏览器(jquery中没有这个方法名，但是jq的一部分选择器也是基于这个方法的原理来实现的)
//获取上一个哥哥元素节点(prev) 
//获取下一个弟弟元素节点(next) 
//获取所有的哥哥元素节点(prevAll)
//获取所有的弟弟元素节点(nextAll)
//获取相邻的两个元素节点(sibling) 
//获取所有的兄弟元素节点(siblings)
//获取第一个元素子节点(firstChild) 获取最后一个元素子节点 这两个方法jq也没有
//index获取当前元素的索引

//prepend 和appendChild对应 增加到某一个容器的开头
//insertAfter 和insertBefore对应 增加到容器中某一个元素后面

//addClass 增加样式类名
//removeClass 删除样式类名
//hasClass 判断是否存在某一个样式类名

//jq:css
//getCss
//setCss
//setGroupCss


//基于内置类的原型扩展一些我们常用的方法





</script>
</body>
</html>